# {{serviceName}}

Microservice scaffold gerado pelo `scaffolding-cli`.

## ğŸš€ Executar com Docker (Recomendado)

### PrÃ©-requisitos

- Docker instalado
- Docker Compose instalado

### ConfiguraÃ§Ã£o

1. Copie o arquivo de exemplo de variÃ¡veis de ambiente:
```bash
cp .env.example .env
```

2. Edite o `.env` conforme necessÃ¡rio:
```env
NODE_ENV=production
PORT=3000
AWS_REGION=us-east-1
# SQS_QUEUE_URL=https://sqs.us-east-1.amazonaws.com/123456789/your-queue
```

### Subir o serviÃ§o

```bash
# Buildar e iniciar o container
docker-compose up -d

# Ver logs
docker-compose logs -f

# Parar o container
docker-compose down
```

O serviÃ§o estarÃ¡ disponÃ­vel em `http://localhost:3000`

### Comandos Ãºteis

```bash
# Rebuild da imagem
docker-compose build

# Reiniciar o serviÃ§o
docker-compose restart

# Ver status
docker-compose ps

# Entrar no container
docker-compose exec {{serviceName}} sh

# Ver logs em tempo real
docker-compose logs -f {{serviceName}}
```

## ğŸ’» Executar localmente (sem Docker)

```bash
# Instalar dependÃªncias
npm install

# Desenvolvimento
npm run dev

# ProduÃ§Ã£o
npm run build
npm start

# Worker (processamento de filas)
npm run worker
```

## ğŸ—ï¸ Arquitetura recomendada (Clean + Fastify)

Estrutura principal (exemplo):

```
src/
â”œâ”€â”€ controllers/          # Recebe requisiÃ§Ãµes, valida e chama Use Cases
â”‚   â””â”€â”€ <nome>.controller.ts
â”œâ”€â”€ use-cases/            # Regras de negÃ³cio (Clean Architecture)
â”‚   â””â”€â”€ <nome>.usecase.ts
â”œâ”€â”€ repositories/         # PersistÃªncia de dados / abstraÃ§Ãµes DB
â”‚   â””â”€â”€ <nome>.repository.ts
â”œâ”€â”€ workers/              # Processamento de filas/eventos (SNS/SQS)
â”‚   â””â”€â”€ <nome>.worker.ts
â”œâ”€â”€ health/               # Endpoints de healthcheck
â”‚   â””â”€â”€ health.route.ts
â”œâ”€â”€ routes/               # DefiniÃ§Ã£o de rotas REST
â”‚   â””â”€â”€ <nome>.routes.ts
â”œâ”€â”€ main.ts               # InicializaÃ§Ã£o do Fastify
â””â”€â”€ server.ts             # ConfiguraÃ§Ã£o do servidor, plugins, middlewares
```

DependÃªncias essenciais jÃ¡ incluÃ­das (Fastify, zod, dotenv, aws-sdk, jwt, etc.).

## ğŸ“œ Scripts

```json
"dev": "ts-node-dev --respawn --transpile-only src/main.ts",
"build": "tsc",
"start": "node dist/main.js",
"test": "jest",
"lint": "eslint . --ext .ts"
```

## âš™ï¸ ConfiguraÃ§Ã£o TypeScript

- `strict: true`
- `outDir: dist`
- `baseUrl` e `paths` prontos para aliases (`@controllers`, `@use-cases`, ...)

## ğŸ“¦ Boilerplate incluso

- `src/controllers/sample.controller.ts`
- `src/use-cases/sample.usecase.ts`
- `src/repositories/sample.repository.ts`
- `src/routes/sample.routes.ts`
- `src/workers/sample.worker.ts`
- `src/health/health.route.ts`

## ğŸ”§ Env & exemplos

- `.env.example` incluÃ­do com variÃ¡veis bÃ¡sicas

## âœ… ObservaÃ§Ãµes de boas prÃ¡ticas

- Use `zod` para validaÃ§Ã£o de payloads e `@opentelemetry/api` para integraÃ§Ã£o futura.
- Separe responsabilidades: controllers -> use-cases -> repositories.
- RepositÃ³rios e use-cases devem ser tenant-aware (usar `X-Tenant-Id`).

## ğŸ”„ CabeÃ§alho de correlaÃ§Ã£o e execuÃ§Ã£o de workers

- Este template jÃ¡ garante que `X-Tenant-Id` seja lido pelos controllers e passado aos use-cases.
- O middleware de entrada tambÃ©m garante/gera `x-correlation-id` e anexa um `requestLogger` ao request para logs estruturados.

## ğŸ”§ Como executar o worker SQS (desenvolvimento)

1. Preencha `.env` com `SQS_QUEUE_URL` e `AWS_REGION`.
2. Rode o worker em dev:

```bash
npm run worker
```

O worker farÃ¡ polling na fila definida por `SQS_QUEUE_URL` e tentarÃ¡ processar mensagens (o `SampleWorker` contÃ©m um `TODO` para o processamento do payload).

## ğŸ”— PropagaÃ§Ã£o de correlaÃ§Ã£o entre serviÃ§os

- Quando o BFF ou outros clientes HTTP chamarem este serviÃ§o, envie o header `x-correlation-id` para manter rastreabilidade. O template do BFF jÃ¡ injeta `x-correlation-id` automaticamente em requisiÃ§Ãµes upstream.
- Para logs consistentes, use `(req as any).requestLogger` dentro de controllers/use-cases quando disponÃ­vel.
